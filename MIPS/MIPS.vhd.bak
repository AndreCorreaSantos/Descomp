library ieee;
use ieee.std_logic_1164.all;

entity MIPS is
  -- Total de bits das entradas e saidas
--   generic ( 
--         simulacao : boolean := FALSE -- para gravar na placa, altere de TRUE para FALSE
--   );
  port   (
    KEY: in std_logic_vector(3 downto 0);
  );
end entity;

architecture arquitetura of MIPS is

  signal CLK : std_logic;
  signal entradaPC : std_logic_vector(31 downto 0);
  signal saidaPC :  std_logic_vector(31 downto 0);
  signal instrucao : std_logic_vector(31 downto 0);
  signal enderecoR1 : std_logic_vector(4 downto 0);
  signal enderecoR2 : std_logic_vector(4 downto 0);
  signal enderecoR3 : std_logic_vector(4 downto 0);
  signal saidaULA : std_logic_vector(31 downto 0);
begin


-- -- Para simular, fica mais simples tirar o edgeDetector
-- gravar:  if simulacao generate
-- CLK <= KEY(0);
-- else generate
-- detectorSub0: work.edgedetector(bordaSubida)
--         port map (clk => CLOCK_50, entrada => CLOCK_50, saida => CLK);
-- end generate;



-- PC
ProgramCounter : entity work.registradorGenerico
            port (DIN => entradaPC,
            DOUT => saidaPC,
            ENABLE  => '1',
            CLK => CLK,
            RST =>  '0'
            );

SomaPC : entity work.somaConstante
            port (
                entrada => saidaPC,
                saida => entradaPC
            );


-- ROM
ROM1: entity work.romMIF generic map(dataWidth => 15)
            port map(
                Endereco => saidaPC,
                Dado => instrucao
            );



-- banco REGS


port
    (
        clk        : in std_logic;
--
        enderecoA       : in std_logic_vector((larguraEndBancoRegs-1) downto 0);
        enderecoB       : in std_logic_vector((larguraEndBancoRegs-1) downto 0);
        enderecoC       : in std_logic_vector((larguraEndBancoRegs-1) downto 0);
--
        dadoEscritaC    : in std_logic_vector((larguraDados-1) downto 0);
--
        escreveC        : in std_logic := '0';
        saidaA          : out std_logic_vector((larguraDados -1) downto 0);
        saidaB          : out std_logic_vector((larguraDados -1) downto 0)
    );

Banco : entity work.bancoRegistradores
                port map(
                    clk => CLK,
                    enderecoA => enderecoRs,
                    enderecoB => enderecoRt,
                    enderecoC => enderecoRd,
                    dadoEscritaC => saidaULA,
                    escreveC => '1', -- PARA INSTRUCOES DO TIPO R SEMPRE ESCREVE O RESULTADO
                    saidaA => saidaA,
                    saidaB => saidaB
                );


-- ULA

ULA : entity work.ULASomaSub
                port map(
                    entradaA => saidaA,
                    entradaB => saidaB,
                    seletor => funct(0),
                    saida => saidaULA
                );


enderecoRs <= instrucao(25 downto 21);
enderecoRt <= instrucao(20 downto 16);
enderecoRd <= instrucao(15 downto 10);

funct <= instrucao(5 downto 0);



end architecture;